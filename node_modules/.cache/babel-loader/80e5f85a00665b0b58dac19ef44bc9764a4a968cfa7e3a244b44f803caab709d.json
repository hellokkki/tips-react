{"ast":null,"code":"'use strict';\n\nconst url = require('url');\nconst gitHosts = require('./git-host-info.js');\nconst GitHost = module.exports = require('./git-host.js');\nconst LRU = require('lru-cache');\nconst cache = new LRU({\n  max: 1000\n});\nconst protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n};\nfunction protocolToRepresentation(protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);\n}\nconst authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\nconst knownProtocols = Object.keys(gitHosts.byShortcut).concat(['http:', 'https:', 'git:', 'git+ssh:', 'git+https:', 'ssh:']);\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') {\n    return;\n  }\n  const key = giturl + JSON.stringify(opts || {});\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts));\n  }\n  return cache.get(key);\n};\nfunction fromUrl(giturl, opts) {\n  if (!giturl) {\n    return;\n  }\n  const url = isGitHubShorthand(giturl) ? 'github:' + giturl : correctProtocol(giturl);\n  const parsed = parseGitUrl(url);\n  if (!parsed) {\n    return parsed;\n  }\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.') ? parsed.hostname.slice(4) : parsed.hostname];\n  const gitHostName = gitHostShortcut || gitHostDomain;\n  if (!gitHostName) {\n    return;\n  }\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];\n  let auth = null;\n  if (authProtocols[parsed.protocol] && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`;\n  }\n  let committish = null;\n  let user = null;\n  let project = null;\n  let defaultRepresentation = null;\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;\n      const firstAt = pathname.indexOf('@');\n      // we ignore auth for shortcuts, so just trim it out\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1);\n      }\n      const lastSlash = pathname.lastIndexOf('/');\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash));\n        // we want nulls only, never empty strings\n        if (!user) {\n          user = null;\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1));\n      } else {\n        project = decodeURIComponent(pathname);\n      }\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4);\n      }\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1));\n      }\n      defaultRepresentation = 'shortcut';\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return;\n      }\n      const segments = gitHostInfo.extract(parsed);\n      if (!segments) {\n        return;\n      }\n      user = segments.user && decodeURIComponent(segments.user);\n      project = decodeURIComponent(segments.project);\n      committish = decodeURIComponent(segments.committish);\n      defaultRepresentation = protocolToRepresentation(parsed.protocol);\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return;\n    } else {\n      throw err;\n    }\n  }\n  return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = arg => {\n  const firstColon = arg.indexOf(':');\n  const proto = arg.slice(0, firstColon + 1);\n  if (knownProtocols.includes(proto)) {\n    return arg;\n  }\n  const firstAt = arg.indexOf('@');\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`;\n    } else {\n      return arg;\n    }\n  }\n  const doubleSlash = arg.indexOf('//');\n  if (doubleSlash === firstColon + 1) {\n    return arg;\n  }\n  return arg.slice(0, firstColon + 1) + '//' + arg.slice(firstColon + 1);\n};\n\n// look for github shorthand inputs, such as npm/cli\nconst isGitHubShorthand = arg => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#');\n  const firstSlash = arg.indexOf('/');\n  const secondSlash = arg.indexOf('/', firstSlash + 1);\n  const firstColon = arg.indexOf(':');\n  const firstSpace = /\\s/.exec(arg);\n  const firstAt = arg.indexOf('@');\n  const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;\n  const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;\n  const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;\n  const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;\n  const hasSlash = firstSlash > 0;\n  // if a # is found, what we really want to know is that the character immediately before # is not a /\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/');\n  const doesNotStartWithDot = !arg.startsWith('.');\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;\n};\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = giturl => {\n  const firstAt = giturl.indexOf('@');\n  const lastHash = giturl.lastIndexOf('#');\n  let firstColon = giturl.indexOf(':');\n  let lastColon = giturl.lastIndexOf(':', lastHash > -1 ? lastHash : Infinity);\n  let corrected;\n  if (lastColon > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    corrected = giturl.slice(0, lastColon) + '/' + giturl.slice(lastColon + 1);\n    // // and we find our new : positions\n    firstColon = corrected.indexOf(':');\n    lastColon = corrected.lastIndexOf(':');\n  }\n  if (firstColon === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    corrected = `git+ssh://${corrected}`;\n  }\n  return corrected;\n};\n\n// try to parse the url as its given to us, if that throws\n// then we try to clean the url and parse that result instead\n// THIS FUNCTION SHOULD NEVER THROW\nconst parseGitUrl = giturl => {\n  let result;\n  try {\n    result = new url.URL(giturl);\n  } catch (err) {}\n  if (result) {\n    return result;\n  }\n  const correctedUrl = correctUrl(giturl);\n  try {\n    result = new url.URL(correctedUrl);\n  } catch (err) {}\n  return result;\n};","map":{"version":3,"names":["url","require","gitHosts","GitHost","module","exports","LRU","cache","max","protocolToRepresentationMap","protocolToRepresentation","protocol","slice","authProtocols","knownProtocols","Object","keys","byShortcut","concat","fromUrl","giturl","opts","key","JSON","stringify","has","set","get","isGitHubShorthand","correctProtocol","parsed","parseGitUrl","gitHostShortcut","gitHostDomain","byDomain","hostname","startsWith","gitHostName","gitHostInfo","auth","username","password","committish","user","project","defaultRepresentation","pathname","firstAt","indexOf","lastSlash","lastIndexOf","decodeURIComponent","endsWith","hash","protocols","includes","segments","extract","err","URIError","arg","firstColon","proto","doubleSlash","firstHash","firstSlash","secondSlash","firstSpace","exec","spaceOnlyAfterHash","index","atOnlyAfterHash","colonOnlyAfterHash","secondSlashOnlyAfterHash","hasSlash","doesNotEndWithSlash","doesNotStartWithDot","correctUrl","lastHash","lastColon","Infinity","corrected","result","URL","correctedUrl"],"sources":["/Users/viktorkondakov/Desktop/programming/projects/tips-react/node_modules/hosted-git-info/index.js"],"sourcesContent":["'use strict'\nconst url = require('url')\nconst gitHosts = require('./git-host-info.js')\nconst GitHost = module.exports = require('./git-host.js')\nconst LRU = require('lru-cache')\nconst cache = new LRU({ max: 1000 })\n\nconst protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)\n}\n\nconst authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nconst knownProtocols = Object.keys(gitHosts.byShortcut).concat(['http:', 'https:', 'git:', 'git+ssh:', 'git+https:', 'ssh:'])\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') {\n    return\n  }\n\n  const key = giturl + JSON.stringify(opts || {})\n\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts))\n  }\n\n  return cache.get(key)\n}\n\nfunction fromUrl (giturl, opts) {\n  if (!giturl) {\n    return\n  }\n\n  const url = isGitHubShorthand(giturl) ? 'github:' + giturl : correctProtocol(giturl)\n  const parsed = parseGitUrl(url)\n  if (!parsed) {\n    return parsed\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol]\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.') ? parsed.hostname.slice(4) : parsed.hostname]\n  const gitHostName = gitHostShortcut || gitHostDomain\n  if (!gitHostName) {\n    return\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain]\n  let auth = null\n  if (authProtocols[parsed.protocol] && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`\n  }\n\n  let committish = null\n  let user = null\n  let project = null\n  let defaultRepresentation = null\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname\n      const firstAt = pathname.indexOf('@')\n      // we ignore auth for shortcuts, so just trim it out\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1)\n      }\n\n      const lastSlash = pathname.lastIndexOf('/')\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash))\n        // we want nulls only, never empty strings\n        if (!user) {\n          user = null\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1))\n      } else {\n        project = decodeURIComponent(pathname)\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4)\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1))\n      }\n\n      defaultRepresentation = 'shortcut'\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return\n      }\n\n      const segments = gitHostInfo.extract(parsed)\n      if (!segments) {\n        return\n      }\n\n      user = segments.user && decodeURIComponent(segments.user)\n      project = decodeURIComponent(segments.project)\n      committish = decodeURIComponent(segments.committish)\n      defaultRepresentation = protocolToRepresentation(parsed.protocol)\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return\n    } else {\n      throw err\n    }\n  }\n\n  return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg) => {\n  const firstColon = arg.indexOf(':')\n  const proto = arg.slice(0, firstColon + 1)\n  if (knownProtocols.includes(proto)) {\n    return arg\n  }\n\n  const firstAt = arg.indexOf('@')\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//')\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n\n  return arg.slice(0, firstColon + 1) + '//' + arg.slice(firstColon + 1)\n}\n\n// look for github shorthand inputs, such as npm/cli\nconst isGitHubShorthand = (arg) => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#')\n  const firstSlash = arg.indexOf('/')\n  const secondSlash = arg.indexOf('/', firstSlash + 1)\n  const firstColon = arg.indexOf(':')\n  const firstSpace = /\\s/.exec(arg)\n  const firstAt = arg.indexOf('@')\n\n  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash)\n  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash)\n  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash)\n  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash)\n  const hasSlash = firstSlash > 0\n  // if a # is found, what we really want to know is that the character immediately before # is not a /\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/')\n  const doesNotStartWithDot = !arg.startsWith('.')\n\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash\n}\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = (giturl) => {\n  const firstAt = giturl.indexOf('@')\n  const lastHash = giturl.lastIndexOf('#')\n  let firstColon = giturl.indexOf(':')\n  let lastColon = giturl.lastIndexOf(':', lastHash > -1 ? lastHash : Infinity)\n\n  let corrected\n  if (lastColon > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    corrected = giturl.slice(0, lastColon) + '/' + giturl.slice(lastColon + 1)\n    // // and we find our new : positions\n    firstColon = corrected.indexOf(':')\n    lastColon = corrected.lastIndexOf(':')\n  }\n\n  if (firstColon === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    corrected = `git+ssh://${corrected}`\n  }\n\n  return corrected\n}\n\n// try to parse the url as its given to us, if that throws\n// then we try to clean the url and parse that result instead\n// THIS FUNCTION SHOULD NEVER THROW\nconst parseGitUrl = (giturl) => {\n  let result\n  try {\n    result = new url.URL(giturl)\n  } catch (err) {}\n\n  if (result) {\n    return result\n  }\n\n  const correctedUrl = correctUrl(giturl)\n  try {\n    result = new url.URL(correctedUrl)\n  } catch (err) {}\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}